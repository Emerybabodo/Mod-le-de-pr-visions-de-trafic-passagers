# -*- coding: utf-8 -*-
"""Prophet prévisions passagers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1th0m9V_bYBRbu7WbrXwZF7f3BGl6jphc
"""

import pandas as pd
from prophet import Prophet
import matplotlib.pyplot as plt

# prompt: charge le fichier excel Prévisions PAX et affiche df

import pandas as pd
from prophet import Prophet
import matplotlib.pyplot as plt

# Assurez-vous que le fichier Excel est dans le même répertoire que votre notebook
# ou spécifiez le chemin complet vers le fichier.
try:
    df = pd.read_excel('/content/sample_data/Prévisions PAX.xlsx')
    print(df)
except FileNotFoundError:
    print("Erreur: Le fichier 'Prévisions PAX.xlsx' n'a pas été trouvé.")
except Exception as e:
    print(f"Une erreur s'est produite: {e}")

# prompt: Supprime toutes les colonnes sauf Années et Passagers

import pandas as pd
from prophet import Prophet
import matplotlib.pyplot as plt


# Assurez-vous que le fichier Excel est dans le même répertoire que votre notebook
# ou spécifiez le chemin complet vers le fichier.
try:
    df = pd.read_excel('/content/sample_data/Prévisions PAX.xlsx')
    # Supprimer toutes les colonnes sauf 'Années' et 'Passagers'
    df = df[['Années', 'Passagers']]
    print(df)
except FileNotFoundError:
    print("Erreur: Le fichier 'Prévisions PAX.xlsx' n'a pas été trouvé.")
except Exception as e:
    print(f"Une erreur s'est produite: {e}")

# prompt: remplace les valeurs aberrantes par la médiane

import pandas as pd
from prophet import Prophet
import matplotlib.pyplot as plt


# Assurez-vous que le fichier Excel est dans le même répertoire que votre notebook
# ou spécifiez le chemin complet vers le fichier.
try:
    df = pd.read_excel('/content/sample_data/Prévisions PAX.xlsx')
    # Supprimer toutes les colonnes sauf 'Années' et 'Passagers'
    df = df[['Années', 'Passagers']]

    # Calcul de la médiane des passagers
    median_passengers = df['Passagers'].median()

    # Définition des limites pour identifier les valeurs aberrantes (par exemple, 1.5 fois l'écart interquartile)
    Q1 = df['Passagers'].quantile(0.25)
    Q3 = df['Passagers'].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    # Remplacement des valeurs aberrantes par la médiane
    df['Passagers'] = df['Passagers'].apply(lambda x: median_passengers if x < lower_bound or x > upper_bound else x)

    print(df)

except FileNotFoundError:
    print("Erreur: Le fichier 'Prévisions PAX.xlsx' n'a pas été trouvé.")
except Exception as e:
    print(f"Une erreur s'est produite: {e}")

df

# prompt: Using dataframe df: Renomme la colonne Années et Date

# Rename the column "Années" to "Date"
df = df.rename(columns={"Années": "Date"})
df.head()

# prompt: Using dataframe df: Harmonise la colonne date en trimestre

import pandas as pd

# Convert the 'Date' column to datetime objects if it's not already
df['Date'] = pd.to_datetime(df['Date'])

# Extract the quarter from the 'Date' column
df['Quarter'] = df['Date'].dt.to_period('Q')

# Display the DataFrame with the new 'Quarter' column
df

# prompt: Using dataframe df: Supprime la colonne Date, maintient Passagers et Quarter et affiche df

# Remove the 'Date' column (if it exists) and display the DataFrame
# Assuming the dataframe is named 'df'

# Check if 'Date' exists before dropping to avoid errors.
if 'Date' in df.columns:
    df = df.drop('Date', axis=1)

# Display the updated dataframe
df

# prompt: Using dataframe df: plot

import altair as alt
import pandas as pd

# Convert the 'Quarter' column to string before plotting
df['Quarter'] = df['Quarter'].astype(str)

alt.Chart(df).mark_line().encode(x='Quarter', y='Passagers')

# prompt: Applique un lissage aux données de la colonne Passagers

# Assuming your dataframe is named 'df' and has columns 'Quarter' and 'Passagers'
# and 'Quarter' is already converted to string

# Using a rolling mean for smoothing
window_size = 4  # Adjust the window size as needed
df['Passagers_smooth'] = df['Passagers'].rolling(window=window_size, center=True).mean()

# Plotting the smoothed data
alt.Chart(df).mark_line().encode(
    x='Quarter',
    y='Passagers_smooth',
    tooltip=['Quarter', 'Passagers', 'Passagers_smooth'] # Add tooltips for better visualization
).properties(title='Passagers (Smoothed)')

# prompt: ajuste les changepoint_prior_scale and seasonality pour les 22 prochains trimestres

# Prepare the data for Prophet
df_prophet = df[['Quarter', 'Passagers']].rename(columns={'Quarter': 'ds', 'Passagers': 'y'})
df_prophet['ds'] = pd.to_datetime(df_prophet['ds'])

# Create and fit the Prophet model with adjusted parameters
model = Prophet(
    changepoint_prior_scale=0.05,  # Adjust as needed
    seasonality_mode='multiplicative', #or 'additive'
    yearly_seasonality=4 #since we have quarterly data
)
model.fit(df_prophet)

# Create future dataframe for 22 quarters ahead
future = model.make_future_dataframe(periods=22, freq='Q')

# Make predictions
forecast = model.predict(future)

# Display the forecast
print(forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(22))


# Plot the forecast
fig1 = model.plot(forecast)
plt.show()

fig2 = model.plot_components(forecast)
plt.show()

# prompt: Affiche la table des résultats des prévisions et des données historiques

# Display the forecast table
print(forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']])

# Display the historical data
df_prophet

# prompt: Using dataframe df_prophet: ajoute les colonnes yhat, yhat_lower et yhat_upper à df_prophet et affiche

# The dataframe already contains the columns 'yhat', 'yhat_lower' and 'yhat_upper'
# so we just display the dataframe.

df_prophet

# prompt: Met la courbes forecast avec une couleur différente

# ... (Your existing code)

# Plot the forecast
fig1 = model.plot(forecast)

# Access the plot's lines and change the color of the forecast line
lines = fig1.gca().lines
lines[0].set_color('blue')  # Change the color of the yhat (forecast) line to blue
lines[1].set_color('orange') # Change the color of the uncertainty interval to orange


plt.show()

fig2 = model.plot_components(forecast)
plt.show()

# Display the forecast with historical data
fig3 = model.plot(forecast)

# Access the historical data from the original DataFrame
historical_data = df_prophet

# Plot the historical data on the same graph
plt.plot(historical_data['ds'], historical_data['y'], label='Données historiques', color='green') # Change color to green

# Customize the plot
plt.xlabel("Trimestre")
plt.ylabel("Nombre de passagers")
plt.title("Prévisions et données historiques des passagers")
plt.legend()  # Show the legend to differentiate between forecast and historical data
plt.show()

# prompt: Calcule les métriques de performances R2,MSE,RMSE,MAE,MAPE

from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
import numpy as np

# ... (Your existing code)

# Prepare the actual and predicted values
y_true = df_prophet['y']
y_pred = forecast['yhat'][:len(y_true)] # Align predictions with the actual values

# Calculate metrics
r2 = r2_score(y_true, y_pred)
mse = mean_squared_error(y_true, y_pred)
rmse = np.sqrt(mse)
mae = mean_absolute_error(y_true, y_pred)

# Calculate MAPE
mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100

# Print the metrics
print(f"R-squared (R2): {r2}")
print(f"Mean Squared Error (MSE): {mse}")
print(f"Root Mean Squared Error (RMSE): {rmse}")
print(f"Mean Absolute Error (MAE): {mae}")
print(f"Mean Absolute Percentage Error (MAPE): {mape:.2f}%")

# prompt: optimise les hyperparamètres du modèle

# ... (Your existing code)

from prophet.diagnostics import cross_validation, performance_metrics

# Perform cross-validation
df_cv = cross_validation(model, initial='700 days', period='180 days', horizon = '365 days')

# Evaluate the performance
df_p = performance_metrics(df_cv, rolling_window=1)
print(df_p.head())

# Find the best hyperparameters using a grid search (example)
import itertools

param_grid = {
    'changepoint_prior_scale': [0.001, 0.01, 0.1, 0.5],
    'seasonality_mode': ['additive', 'multiplicative'],
    'seasonality_prior_scale': [0.01, 0.1, 1.0, 10.0]
}

# Generate all combinations of parameters
all_params = [dict(zip(param_grid.keys(), v)) for v in itertools.product(*param_grid.values())]
rmses = []  # Store RMSEs for each params combination

# Use cross-validation to evaluate all parameters
for params in all_params:
    m = Prophet(**params).fit(df_prophet)  # Fit model with given params
    df_cv = cross_validation(m, initial='700 days', period='180 days', horizon = '365 days')
    df_p = performance_metrics(df_cv, rolling_window=1)
    rmses.append(df_p['rmse'].mean())

# Find the best parameters
tuning_results = pd.DataFrame(all_params)
tuning_results['rmse'] = rmses
print(tuning_results)
best_params = all_params[np.argmin(rmses)]
print(f"Best parameters: {best_params}")

# Train the model with the best parameters
best_model = Prophet(**best_params).fit(df_prophet)
future = best_model.make_future_dataframe(periods=22, freq='Q')
forecast = best_model.predict(future)

# ... (Rest of your existing code for plotting and evaluation)

# prompt: Applique le modèle avec les meilleurs paramètres pour prédire les passagers

# Assuming 'best_params' and 'df_prophet' are defined from the previous code block.

# Train the model with the best parameters
best_model = Prophet(**best_params).fit(df_prophet)
future = best_model.make_future_dataframe(periods=22, freq='Q')
forecast = best_model.predict(future)

# Plot the forecast
fig1 = best_model.plot(forecast)
plt.show()

fig2 = best_model.plot_components(forecast)
plt.show()

# Display the forecast with historical data
fig3 = best_model.plot(forecast)

# Access the historical data from the original DataFrame
historical_data = df_prophet

# Plot the historical data on the same graph
plt.plot(historical_data['ds'], historical_data['y'], label='Données historiques', color='green')

# Customize the plot
plt.xlabel("Trimestre")
plt.ylabel("Nombre de passagers")
plt.title("Prévisions et données historiques des passagers (Meilleurs paramètres)")
plt.legend()
plt.show()


# Prepare the actual and predicted values for the best model
y_true = df_prophet['y']
y_pred = forecast['yhat'][:len(y_true)]

# Calculate metrics for the best model
r2 = r2_score(y_true, y_pred)
mse = mean_squared_error(y_true, y_pred)
rmse = np.sqrt(mse)
mae = mean_absolute_error(y_true, y_pred)
mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100

print("Metrics with best parameters:")
print(f"R-squared (R2): {r2}")
print(f"Mean Squared Error (MSE): {mse}")
print(f"Root Mean Squared Error (RMSE): {rmse}")
print(f"Mean Absolute Error (MAE): {mae}")
print(f"Mean Absolute Percentage Error (MAPE): {mape:.2f}%")

print(forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(22))

# prompt: print this results here

import pandas as pd
from prophet import Prophet
import matplotlib.pyplot as plt
import altair as alt
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
import numpy as np
from prophet.diagnostics import cross_validation, performance_metrics
import itertools

# ... (Your existing code) ...

print(forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(22))

forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(22)